// This is the minified and stringified code of the playout-audio-worklet-processor package.
export const worklet = `(()=>{"use strict";const e=128;class t extends AudioWorkletProcessor{constructor({numberOfInputs:t,numberOfOutputs:r,outputChannelCount:n,processorOptions:o}){if(0!==t)throw new Error("The numberOfInputs must be 0.");if(1!==r)throw new Error("The numberOfOutputs must be 1.");if(void 0===n||1!==n.length)throw new Error("The outputChannelCount must define a single output.");const[i]=n;if("object"!=typeof o||null===o)throw new Error;const s="readPointerView"in o?o.readPointerView:null;if(!(s instanceof Uint8Array||s instanceof Uint16Array||s instanceof Uint32Array))throw new Error('The readPointerView needs to be an instance of "Uint8Array", "Uint16Array", or "Uint32Array".');if(1!==s.length)throw new Error("The readPointerView needs to have a length of 1.");const a="startView"in o?o.startView:null;if(!(a instanceof Uint16Array))throw new Error('The startView needs to be an instance of "Uint16Array".');if(1!==a.length)throw new Error("The startView needs to have a length of 1.");const h="stopView"in o?o.stopView:null;if(!(h instanceof Uint16Array))throw new Error('The stopView needs to be an instance of "Uint16Array".');if(1!==h.length)throw new Error("The stopView needs to have a length of 1.");const w="storageView"in o?o.storageView:null;if(!(w instanceof Float32Array))throw new Error('The storageView needs to be an instance of "Float32Array".');const f=w.length/i;if(!Number.isInteger(f))throw new Error("The storageView needs to have a length which is a multiple of the number of channels.");const l=f/e;if(!Number.isInteger(l))throw new Error("The capacity can only be a multiple of the render quantum size.");const u="writePointerView"in o?o.writePointerView:null;if(!(u instanceof Uint8Array||u instanceof Uint16Array||u instanceof Uint32Array))throw new Error('The writePointerView needs to be an instance of "Uint8Array", "Uint16Array", or "Uint32Array".');if(1!==u.length)throw new Error("The writePointerView needs to have a length of 1.");if(s.byteLength!==u.byteLength)throw new Error("The pointer need to be of the same size.");if(f>=2**(8*s.byteLength-1))throw new Error("The capacity exceeds the pointer range.");super(),this._isStarted=!1,this._numberOfChannels=i,this._numberOfSlots=l,this._readPointerView=s,this._slots=Array.from({length:l},(t,r)=>{const n=r*e;return Array.from({length:i},(t,r)=>{const o=n+r*l*e;return w.subarray(o,o+e)})}),this._startView=a,this._stopView=h,this._writePointerView=u}process(e,[t]){if(!this._isStarted){if(!this._readStart())return!0;this._isStarted=!0}const r=!(!this._readStorage(t)&&this._readStop());return r||(this.port.postMessage(null),this.port.close()),r}_readStart(){return 1===Atomics.load(this._startView,0)}_readStop(){return 1===Atomics.load(this._stopView,0)}_readStorage(t){const r=Atomics.load(this._readPointerView,0)/e;if(Math.floor((524287&Atomics.load(this._writePointerView,0))/e)===r)return!1;const n=this._slots[r%this._numberOfSlots];for(let e=0;e<this._numberOfChannels;e+=1)t[e].set(n[e]);return Atomics.store(this._readPointerView,0,(r+1)%(2*this._numberOfSlots)*e),!0}}t.parameterDescriptors=[],registerProcessor("playout-audio-worklet-processor",t)})();`; // tslint:disable-line:max-line-length
